## Exercise 1

The results can be printed to stdout by running the bash script `script.sh`, after making it executable with `chmod +x script.sh`. The number of processes can be easily modified with the env variable `PROCS`.

In this exercise we were asked to implement a ring communication pattern among a given number of processes. At the beginning, each one initializes two local buffers to be equal to their rank. One will be used to store the accumulated results, while the other will contain the numbers to be summed. Subsequently, all the processes except 0 (which, in this sense, has been elected to perform as termination process) make a call to `MPI_Recv` to get the buffer to be summed from the process to the left, and then perform the computation. Once out of the if statement, all the processes call `MPI_Isend` to forward a buffer to be summed to the process on the right. Eventually, the second if statement makes sure process 0 has completed its send before it receives the result from the final process. Right and left processes are swiftly computed with the `PROC_UP` and `PROC_DOWN` macros defined on top of the program.
Notice that, in order to optimize the program and sort of overlap communication and computation, we could rewrite the send as a non-blocking send. In fact, `MPI_Isend` returns without necessarily accomplishing the communication. Also notice that: 1) the receving call could not be made into a non-blocking one, since in order to perform a correct summation we need to have received the input buffer from the left process; 2) there is no matching `MPI_Wait`, since the corresponding receive is implicitly blocking.
